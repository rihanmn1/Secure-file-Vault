
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Secure File Vault</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM for the application logic -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      /* Custom scrollbar for a better look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
      body {
        overscroll-behavior: none;
      }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-slate-900 text-slate-200">
    <div id="root"></div>

    <script type="text/babel">
      // All application code is combined here.
      // Babel will transpile it on-the-fly in the browser.

      // --- START: types.ts ---
      const AppState = {
        LOADING: 0,
        SETUP: 1,
        LOCKED: 2,
        UNLOCKED: 3,
        ERROR: 4,
      };

      // --- START: services/crypto.ts ---
      const cryptoService = (() => {
        const PBKDF2_ITERATIONS = 250000;
        const SALT_LENGTH = 16; // bytes
        const IV_LENGTH = 12; // bytes for AES-GCM

        const arrayBufferToBase64 = (buffer) => {
          let binary = '';
          const bytes = new Uint8Array(buffer);
          const len = bytes.byteLength;
          const CHUNK_SIZE = 8192;
          for (let i = 0; i < len; i += CHUNK_SIZE) {
            binary += String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK_SIZE));
          }
          return btoa(binary);
        };

        const base64ToArrayBuffer = (base64) => {
          const binaryString = atob(base64);
          const len = binaryString.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        };

        const deriveKey = async (password, salt, usage) => {
          const masterKey = await window.crypto.subtle.importKey(
            'raw',
            new TextEncoder().encode(password),
            { name: 'PBKDF2' },
            false,
            ['deriveKey']
          );

          return window.crypto.subtle.deriveKey(
            { name: 'PBKDF2', salt, iterations: PBKDF2_ITERATIONS, hash: 'SHA-256' },
            masterKey,
            { name: 'AES-GCM', length: 256 },
            true,
            usage
          );
        };

        return {
          hashPassword: async (password) => {
            const salt = window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
            const key = await deriveKey(password, salt, ['encrypt']);
            const keyData = await window.crypto.subtle.exportKey('raw', key);
            const hash = await window.crypto.subtle.digest('SHA-256', keyData);
            return {
              hash: arrayBufferToBase64(hash),
              salt: arrayBufferToBase64(salt.buffer),
            };
          },

          verifyPasswordAndDeriveKey: async (password, storedHash, storedSalt) => {
            const salt = new Uint8Array(base64ToArrayBuffer(storedSalt));
            const key = await deriveKey(password, salt, ['encrypt', 'decrypt']);
            const keyData = await window.crypto.subtle.exportKey('raw', key);
            const hash = await window.crypto.subtle.digest('SHA-256', keyData);

            if (arrayBufferToBase64(hash) === storedHash) {
              return key;
            }
            return null;
          },

          encryptFile: async (fileData, key) => {
            const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
            const encryptedData = await window.crypto.subtle.encrypt(
              { name: 'AES-GCM', iv },
              key,
              fileData
            );
            return {
              encryptedData,
              iv: arrayBufferToBase64(iv.buffer),
            };
          },

          decryptFile: async (encryptedData, key, iv) => {
            const ivBuffer = base64ToArrayBuffer(iv);
            return await window.crypto.subtle.decrypt(
              { name: 'AES-GCM', iv: ivBuffer },
              key,
              encryptedData
            );
          }
        };
      })();

      // --- START: services/db.ts ---
      const dbService = new (class DBService {
          constructor() {
            this.DB_NAME = 'SecureFileVault';
            this.DB_VERSION = 1;
            this.CONFIG_STORE = 'config';
            this.METADATA_STORE = 'metadata';
            this.DATA_STORE = 'data';
            this.db = null;
          }

          async init() {
            if (this.db) return;
            return new Promise((resolve, reject) => {
              const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
              request.onerror = () => reject(new Error('Failed to open database'));
              request.onsuccess = () => {
                this.db = request.result;
                resolve();
              };
              request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.CONFIG_STORE)) {
                  db.createObjectStore(this.CONFIG_STORE, { keyPath: 'key' });
                }
                if (!db.objectStoreNames.contains(this.METADATA_STORE)) {
                  db.createObjectStore(this.METADATA_STORE, { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains(this.DATA_STORE)) {
                  db.createObjectStore(this.DATA_STORE, { keyPath: 'id' });
                }
              };
            });
          }
        
          getStore(storeName, mode) {
            if (!this.db) throw new Error('Database not initialized');
            return this.db.transaction(storeName, mode).objectStore(storeName);
          }

          requestPromise(request) {
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
          }

          async saveConfig(config) {
            const store = this.getStore(this.CONFIG_STORE, 'readwrite');
            const fullConfig = { key: 'master', ...config };
            await this.requestPromise(store.put(fullConfig));
          }

          async getConfig() {
            const store = this.getStore(this.CONFIG_STORE, 'readonly');
            const result = await this.requestPromise(store.get('master'));
            return result || null;
          }
          
          async saveFile(metadata, data) {
            if (!this.db) throw new Error('Database not initialized');
            const tx = this.db.transaction([this.METADATA_STORE, this.DATA_STORE], 'readwrite');
            tx.objectStore(this.METADATA_STORE).put(metadata);
            tx.objectStore(this.DATA_STORE).put({ id: metadata.id, data });

            return new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
          }

          async getAllFileMetadata() {
            const store = this.getStore(this.METADATA_STORE, 'readonly');
            return await this.requestPromise(store.getAll());
          }

          async getFileData(id) {
            const store = this.getStore(this.DATA_STORE, 'readonly');
            const result = await this.requestPromise(store.get(id));
            return result ? result.data : null;
          }

          async deleteFile(id) {
            if (!this.db) throw new Error('Database not initialized');
            const tx = this.db.transaction([this.METADATA_STORE, this.DATA_STORE], 'readwrite');
            tx.objectStore(this.METADATA_STORE).delete(id);
            tx.objectStore(this.DATA_STORE).delete(id);

            return new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
          }
          
          async clearAllData() {
            if (!this.db) throw new Error('Database not initialized');
            const tx = this.db.transaction([this.CONFIG_STORE, this.METADATA_STORE, this.DATA_STORE], 'readwrite');
            tx.objectStore(this.CONFIG_STORE).clear();
            tx.objectStore(this.METADATA_STORE).clear();
            tx.objectStore(this.DATA_STORE).clear();

            return new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
          }
          
          _arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            const CHUNK_SIZE = 8192;
            for (let i = 0; i < len; i += CHUNK_SIZE) {
              binary += String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK_SIZE));
            }
            return btoa(binary);
          }

          _base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
          }

          async exportVault() {
            const config = await this.getConfig();
            const metadata = await this.getAllFileMetadata();
            const dataPromises = metadata.map(m => this.getFileData(m.id));
            const dataBlobs = await Promise.all(dataPromises);

            const fileData = metadata.map((m, i) => ({
              metadata: m,
              data: dataBlobs[i] ? this._arrayBufferToBase64(dataBlobs[i]) : null
            }));

            return { config, files: fileData };
          }
          
          async importVault(vaultData) {
            await this.clearAllData();
            if(vaultData.config) {
              const {key, ...configData} = vaultData.config;
              await this.saveConfig(configData);
            }
            if(vaultData.files && Array.isArray(vaultData.files)) {
              for(const file of vaultData.files) {
                if(file.metadata && file.data) {
                  const dataBuffer = this._base64ToArrayBuffer(file.data);
                  await this.saveFile(file.metadata, dataBuffer);
                }
              }
            }
          }
      })();
      
      // --- START: hooks/useAutoLock.ts ---
      const useAutoLock = (onIdle) => {
        const { useEffect, useRef, useCallback } = React;
        const INACTIVITY_TIMEOUT = 15 * 60 * 1000;
        const timeoutId = useRef(null);

        const resetTimer = useCallback(() => {
          if (timeoutId.current) {
            clearTimeout(timeoutId.current);
          }
          timeoutId.current = window.setTimeout(onIdle, INACTIVITY_TIMEOUT);
        }, [onIdle]);

        useEffect(() => {
          const events = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'];
          const eventListener = () => resetTimer();

          events.forEach(event => window.addEventListener(event, eventListener));
          resetTimer();

          return () => {
            if (timeoutId.current) {
              clearTimeout(timeoutId.current);
            }
            events.forEach(event => window.removeEventListener(event, eventListener));
          };
        }, [resetTimer]);
        
        return resetTimer;
      };

      // --- START: components/icons.tsx ---
      const LockIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
        </svg>
      );
      const EyeIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
          <circle cx="12" cy="12" r="3"></circle>
        </svg>
      );
      const EyeOffIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"></path>
          <path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"></path>
          <path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"></path>
          <line x1="2" x2="22" y1="2" y2="22"></line>
        </svg>
      );
      const UploadIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" x2="12" y1="3" y2="15"></line>
        </svg>
      );
      const FileIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
        </svg>
      );
      const DownloadIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" x2="12" y1="15" y2="3"></line>
        </svg>
      );
      const TrashIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M3 6h18"></path>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          <line x1="10" x2="10" y1="11" y2="17"></line>
          <line x1="14" x2="14" y1="11" y2="17"></line>
        </svg>
      );
      const InfoIcon = ({ className }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="16" x2="12" y2="12"></line>
              <line x1="12" y1="8" x2="12.01" y2="8"></line>
          </svg>
      );
      const SearchIcon = ({ className }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
              <circle cx="11" cy="11" r="8"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
      );
      const LogOutIcon = ({ className }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
              <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
              <polyline points="16 17 21 12 16 7"></polyline>
              <line x1="21" y1="12" x2="9" y2="12"></line>
          </svg>
      );

      // --- START: components/Toast.tsx ---
      const Toast = ({ toast, removeToast }) => {
        const { useEffect } = React;
        useEffect(() => {
          const timer = setTimeout(() => removeToast(toast.id), 5000);
          return () => clearTimeout(timer);
        }, [toast, removeToast]);

        const typeClasses = { success: 'bg-green-600', error: 'bg-red-600', info: 'bg-sky-600' };
        const Icon = ({ type }) => {
          switch (type) {
            case 'success': return <span className="text-xl">&#x2713;</span>;
            case 'error': return <span className="text-xl">!</span>;
            case 'info': return <span className="text-xl">i</span>;
          }
        };

        return (
          <div className={`w-full max-w-sm p-4 rounded-lg shadow-lg flex items-center space-x-3 text-white ${typeClasses[toast.type]}`}>
            <div className="font-bold"><Icon type={toast.type} /></div>
            <p className="flex-grow">{toast.message}</p>
            <button onClick={() => removeToast(toast.id)}>&times;</button>
          </div>
        );
      };

      const ToastContainer = ({ toasts, removeToast }) => (
        <div className="fixed bottom-4 right-4 space-y-2 z-50 w-full max-w-sm">
          {toasts.map(toast => <Toast key={toast.id} toast={toast} removeToast={removeToast} />)}
        </div>
      );

      // --- START: components/Modal.tsx ---
      const Modal = ({ onClose, title, children }) => {
        const { useEffect } = React;
        useEffect(() => {
          const handleEsc = (event) => {
            if (event.key === 'Escape') onClose();
          };
          window.addEventListener('keydown', handleEsc);
          return () => window.removeEventListener('keydown', handleEsc);
        }, [onClose]);

        return (
          <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50" onClick={onClose}>
            <div className="bg-slate-800 rounded-lg shadow-xl w-full max-w-lg p-6 border border-slate-700" onClick={(e) => e.stopPropagation()}>
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold text-slate-100">{title}</h2>
                <button onClick={onClose} className="text-slate-400 hover:text-white text-2xl leading-none">&times;</button>
              </div>
              <div>{children}</div>
            </div>
          </div>
        );
      };

      // --- START: components/FileUpload.tsx ---
      const FileUpload = ({ onFileUpload }) => {
        const { useState, useRef, useCallback } = React;
        const [isDragging, setIsDragging] = useState(false);
        const fileInputRef = useRef(null);

        const handleDrag = useCallback((e) => {
          e.preventDefault();
          e.stopPropagation();
          if (e.type === 'dragenter' || e.type === 'dragover') {
            setIsDragging(true);
          } else if (e.type === 'dragleave') {
            setIsDragging(false);
          }
        }, []);

        const handleDrop = useCallback((e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsDragging(false);
          if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            onFileUpload(e.dataTransfer.files[0]);
            e.dataTransfer.clearData();
          }
        }, [onFileUpload]);
        
        const handleClick = () => fileInputRef.current?.click();
        
        const handleChange = (e) => {
          if (e.target.files && e.target.files.length > 0) {
              onFileUpload(e.target.files[0]);
          }
          e.target.value = '';
        };

        return (
          <div
            onDragEnter={handleDrag} onDragOver={handleDrag} onDragLeave={handleDrag} onDrop={handleDrop} onClick={handleClick}
            className={`p-10 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors duration-300 ${isDragging ? 'border-sky-400 bg-sky-900/50' : 'border-slate-600 hover:border-sky-500 hover:bg-slate-800'}`}>
            <input ref={fileInputRef} type="file" className="hidden" onChange={handleChange} />
            <UploadIcon className="w-12 h-12 mx-auto text-slate-400 mb-4" />
            <p className="text-slate-200">Drag & Drop file here</p>
            <p className="text-sm text-slate-400">or click to select a file</p>
          </div>
        );
      };

      // --- START: components/FileList.tsx ---
      const FileList = ({ files, isLoading, onDownload, onDelete, onInfo }) => {
        const formatBytes = (bytes, decimals = 2) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        };

        const FileItem = ({ file }) => (
          <div className="flex items-center p-4 bg-slate-800 rounded-lg hover:bg-slate-700/50 transition-colors duration-200">
            <FileIcon className="w-8 h-8 text-sky-400 mr-4 flex-shrink-0" />
            <div className="flex-grow min-w-0">
              <p className="font-medium text-slate-100 truncate">{file.name}</p>
              <p className="text-sm text-slate-400">{formatBytes(file.size)}</p>
            </div>
            <div className="flex items-center gap-2 ml-4 flex-shrink-0">
              <button onClick={() => onInfo(file)} className="p-2 rounded-full hover:bg-slate-600 text-slate-400 hover:text-white transition"><InfoIcon className="w-5 h-5" /></button>
              <button onClick={() => onDownload(file)} className="p-2 rounded-full hover:bg-slate-600 text-slate-400 hover:text-green-400 transition"><DownloadIcon className="w-5 h-5" /></button>
              <button onClick={() => onDelete(file)} className="p-2 rounded-full hover:bg-slate-600 text-slate-400 hover:text-red-400 transition"><TrashIcon className="w-5 h-5" /></button>
            </div>
          </div>
        );

        if (isLoading) {
          return <div className="p-6 bg-slate-800 rounded-lg text-center"><p className="text-slate-400">Loading files...</p></div>;
        }

        if (files.length === 0) {
          return <div className="p-6 bg-slate-800 rounded-lg text-center"><p className="text-slate-400">Your vault is empty. Upload a file to get started.</p></div>;
        }

        return <div className="space-y-3">{files.map(file => <FileItem key={file.id} file={file} />)}</div>;
      };
      
      // --- START: components/AuthScreen.tsx ---
      const AuthScreen = ({ appState, onLogin, addToast }) => {
        const { useState } = React;
        const [password, setPassword] = useState('');
        const [confirmPassword, setConfirmPassword] = useState('');
        const [passwordVisible, setPasswordVisible] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [passwordStrength, setPasswordStrength] = useState(0);
        const isSetup = appState === AppState.SETUP;

        const checkStrength = (pass) => {
            let score = 0;
            if (!pass) { setPasswordStrength(0); return; }
            if (pass.length >= 8) score++;
            if (pass.length >= 12) score++;
            if (/[A-Z]/.test(pass)) score++;
            if (/[0-9]/.test(pass)) score++;
            if (/[^A-Za-z0-9]/.test(pass)) score++;
            setPasswordStrength(score);
        };

        const handlePasswordChange = (e) => {
            const newPass = e.target.value;
            setPassword(newPass);
            if (isSetup) checkStrength(newPass);
        };

        const handleSubmit = async (e) => {
          e.preventDefault();
          if (isLoading) return;
          if (isSetup && password !== confirmPassword) {
            addToast({ type: 'error', message: 'Passwords do not match.' });
            return;
          }
          if (isSetup && passwordStrength < 3) {
            addToast({ type: 'error', message: 'Password is too weak.' });
            return;
          }
          setIsLoading(true);

          try {
            if (isSetup) {
              const { hash, salt } = await cryptoService.hashPassword(password);
              await dbService.saveConfig({ hash, salt });
              const key = await cryptoService.verifyPasswordAndDeriveKey(password, hash, salt);
              if (key) onLogin(key);
              else throw new Error('Key derivation failed after setup.');
            } else {
              const config = await dbService.getConfig();
              if (!config) throw new Error('Vault configuration not found.');
              const key = await cryptoService.verifyPasswordAndDeriveKey(password, config.hash, config.salt);
              if (key) onLogin(key);
              else addToast({ type: 'error', message: 'Invalid password.' });
            }
          } catch (error) {
            console.error('Authentication error:', error);
            addToast({ type: 'error', message: 'An error occurred. Please try again.' });
          } finally {
            setIsLoading(false);
          }
        };
        
        const strengthColors = ['bg-red-500', 'bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500'];
        const strengthText = ['Very Weak', 'Very Weak', 'Weak', 'Medium', 'Strong', 'Very Strong'];

        return (
          <div className="flex items-center justify-center min-h-screen bg-slate-900 px-4">
            <div className="w-full max-w-md p-8 space-y-8 bg-slate-800 rounded-lg shadow-2xl">
              <div className="text-center">
                  <LockIcon className="w-16 h-16 mx-auto text-sky-400" />
                  <h1 className="mt-4 text-3xl font-bold text-slate-100">Secure File Vault</h1>
                  <p className="mt-2 text-slate-400">{isSetup ? 'Create a master password.' : 'Unlock your vault.'}</p>
              </div>
              <form className="space-y-6" onSubmit={handleSubmit}>
                <div className="relative">
                  <input id="password" type={passwordVisible ? 'text' : 'password'} required value={password} onChange={handlePasswordChange} className="w-full px-4 py-3 text-white bg-slate-700 border border-slate-600 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500" placeholder="Master Password" />
                  <button type="button" onClick={() => setPasswordVisible(!passwordVisible)} className="absolute inset-y-0 right-0 flex items-center px-4 text-slate-400 hover:text-sky-400">
                      {passwordVisible ? <EyeOffIcon className="w-5 h-5" /> : <EyeIcon className="w-5 h-5" />}
                  </button>
                </div>
                {isSetup && (
                  <>
                      <div>
                          <input id="confirm-password" type={passwordVisible ? 'text' : 'password'} required value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} className="w-full px-4 py-3 text-white bg-slate-700 border border-slate-600 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500" placeholder="Confirm Password" />
                      </div>
                      <div className="w-full bg-slate-700 rounded-full h-2.5">
                          <div className={`h-2.5 rounded-full transition-all duration-300 ${strengthColors[passwordStrength]}`} style={{ width: `${(passwordStrength / 5) * 100}%` }}></div>
                      </div>
                      <p className="text-sm text-center text-slate-400">Strength: {strengthText[passwordStrength]}</p>
                  </>
                )}
                <div>
                  <button type="submit" disabled={isLoading} className="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-sky-600 hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800 focus:ring-sky-500 disabled:bg-sky-800 disabled:cursor-not-allowed">
                    {isLoading ? <div className="w-5 h-5 border-2 border-dashed rounded-full animate-spin"></div> : (isSetup ? 'Create Vault' : 'Unlock')}
                  </button>
                </div>
              </form>
              <div className="text-xs text-center text-slate-500">
                  <p><strong>Warning:</strong> If you forget your password, your files will be permanently inaccessible. It cannot be recovered.</p>
              </div>
            </div>
          </div>
        );
      };
      
      // --- START: components/Dashboard.tsx ---
      const Dashboard = ({ encryptionKey, onLogout, addToast }) => {
        const { useState, useEffect, useCallback, useMemo } = React;
        useAutoLock(onLogout);
        const [files, setFiles] = useState([]);
        const [searchQuery, setSearchQuery] = useState('');
        const [isLoading, setIsLoading] = useState(true);
        const [modal, setModal] = useState(null);

        const formatBytes = (bytes, decimals = 2) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        };
        
        const fetchFiles = useCallback(async () => {
          setIsLoading(true);
          try {
            const allFiles = await dbService.getAllFileMetadata();
            setFiles(allFiles.sort((a, b) => b.uploadDate - a.uploadDate));
          } catch (error) { addToast({ type: 'error', message: 'Failed to load files.' }); } 
          finally { setIsLoading(false); }
        }, [addToast]);

        useEffect(() => { fetchFiles(); }, [fetchFiles]);

        const handleFileUpload = async (file) => {
          try {
            addToast({ type: 'info', message: `Encrypting ${file.name}...` });
            const fileData = await file.arrayBuffer();
            const { encryptedData, iv } = await cryptoService.encryptFile(fileData, encryptionKey);
            const metadata = { id: crypto.randomUUID(), name: file.name, type: file.type || 'application/octet-stream', size: file.size, encryptedSize: encryptedData.byteLength, iv, uploadDate: Date.now() };
            await dbService.saveFile(metadata, encryptedData);
            addToast({ type: 'success', message: `${file.name} successfully secured.` });
            fetchFiles();
          } catch (error) {
            console.error('Upload failed:', error);
            addToast({ type: 'error', message: `Failed to upload ${file.name}.` });
          }
        };

        const handleDownloadFile = async (file) => {
          try {
            addToast({ type: 'info', message: `Decrypting ${file.name}...` });
            const encryptedData = await dbService.getFileData(file.id);
            if (!encryptedData) throw new Error('File data not found');
            const decryptedData = await cryptoService.decryptFile(encryptedData, encryptionKey, file.iv);
            const blob = new Blob([decryptedData], { type: file.type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = file.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            addToast({ type: 'success', message: `${file.name} downloaded.` });
          } catch (error) {
            console.error('Download failed:', error);
            addToast({ type: 'error', message: `Failed to download ${file.name}.` });
          }
        };

        const handleDeleteFile = async (id) => {
          try {
            await dbService.deleteFile(id);
            addToast({ type: 'success', message: 'File deleted.' });
            fetchFiles();
          } catch (error) { addToast({ type: 'error', message: 'Failed to delete file.' }); }
          finally { setModal(null); }
        };
        
        const handleExportVault = async () => {
          try {
            addToast({type: 'info', message: 'Exporting vault...'});
            const vaultData = await dbService.exportVault();
            const vaultJson = JSON.stringify(vaultData, null, 2);
            const blob = new Blob([vaultJson], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `secure-vault-backup-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            addToast({type: 'success', message: 'Vault exported.'});
          } catch (e) { addToast({type: 'error', message: 'Failed to export vault.'}); }
        };
        
        const handleImportVault = (e) => {
          const file = e.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = async (event) => {
            try {
              const vaultData = JSON.parse(event.target?.result);
              addToast({type: 'info', message: 'Importing vault...'});
              await dbService.importVault(vaultData);
              addToast({type: 'success', message: 'Vault imported. Please log out and back in.'});
              fetchFiles();
            } catch (error) { addToast({type: 'error', message: 'Failed to import vault file.'}); }
          };
          reader.readAsText(file);
          e.target.value = '';
        };
        
        const handleClearAllData = async () => {
            await dbService.clearAllData();
            addToast({type: 'success', message: 'All data has been cleared.'});
            window.location.reload();
        };

        const filteredFiles = useMemo(() => files.filter(file => file.name.toLowerCase().includes(searchQuery.toLowerCase())), [files, searchQuery]);
        const vaultStats = useMemo(() => ({ count: files.length, size: formatBytes(files.reduce((acc, file) => acc + file.encryptedSize, 0)) }), [files]);

        return (
          <div className="p-4 sm:p-6 md:p-8 min-h-screen">
            <header className="flex flex-wrap items-center justify-between gap-4 mb-6">
              <h1 className="text-3xl font-bold text-slate-100">My Vault</h1>
              <div className="flex items-center gap-4">
                <div className="relative">
                  <input type="text" placeholder="Search files..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="pl-10 pr-4 py-2 w-48 sm:w-64 bg-slate-800 border border-slate-700 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500" />
                  <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400" />
                </div>
                <button onClick={onLogout} className="flex items-center gap-2 px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-md transition">
                  <LogOutIcon className="w-5 h-5" />
                  <span className="hidden sm:inline">Lock Vault</span>
                </button>
              </div>
            </header>

            <main className="grid grid-cols-1 lg:grid-cols-3 gap-8">
              <div className="lg:col-span-2">
                <FileUpload onFileUpload={handleFileUpload} />
              </div>
              <div className="lg:col-span-1 p-6 bg-slate-800 rounded-lg">
                  <h2 className="text-xl font-semibold mb-4 text-slate-200">Vault Info</h2>
                  <div className="space-y-3 text-slate-300">
                      <p>Files Stored: <span className="font-medium text-sky-400">{vaultStats.count}</span></p>
                      <p>Total Size: <span className="font-medium text-sky-400">{vaultStats.size}</span></p>
                  </div>
                  <div className="mt-6 space-y-3">
                    <button onClick={handleExportVault} className="w-full text-center py-2 px-4 bg-green-600 hover:bg-green-700 rounded-md transition">Export Vault</button>
                    <label htmlFor="import-vault" className="w-full block text-center py-2 px-4 bg-yellow-600 hover:bg-yellow-700 rounded-md transition cursor-pointer">Import Vault</label>
                    <input type="file" id="import-vault" accept=".json" className="hidden" onChange={handleImportVault} />
                    <button onClick={() => setModal({type: 'clear', data: null})} className="w-full text-center py-2 px-4 bg-red-700 hover:bg-red-800 rounded-md transition">Clear All Data</button>
                  </div>
              </div>

              <div className="lg:col-span-3">
                <FileList files={filteredFiles} isLoading={isLoading} onDownload={handleDownloadFile} onDelete={(file) => setModal({ type: 'delete', data: file })} onInfo={(file) => setModal({ type: 'info', data: file })} />
              </div>
            </main>
            
            {modal && modal.type === 'delete' && (
              <Modal onClose={() => setModal(null)} title="Confirm Deletion">
                <p>Are you sure you want to permanently delete "{modal.data.name}"?</p>
                <div className="flex justify-end gap-4 mt-6">
                  <button onClick={() => setModal(null)} className="px-4 py-2 bg-slate-600 hover:bg-slate-500 rounded-md">Cancel</button>
                  <button onClick={() => handleDeleteFile(modal.data.id)} className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md">Delete</button>
                </div>
              </Modal>
            )}

            {modal && modal.type === 'info' && (
              <Modal onClose={() => setModal(null)} title="File Information">
                  <div className="space-y-2 text-slate-300 break-all">
                      <p><strong>Filename:</strong> {modal.data.name}</p>
                      <p><strong>Original Size:</strong> {formatBytes(modal.data.size)}</p>
                      <p><strong>Stored Size:</strong> {formatBytes(modal.data.encryptedSize)}</p>
                      <p><strong>File Type:</strong> {modal.data.type}</p>
                      <p><strong>Uploaded:</strong> {new Date(modal.data.uploadDate).toLocaleString()}</p>
                      <p><strong>Encryption:</strong> AES-256-GCM</p>
                      <p><strong>IV (Base64):</strong> {modal.data.iv}</p>
                  </div>
                  <div className="flex justify-end mt-6"><button onClick={() => setModal(null)} className="px-4 py-2 bg-sky-600 hover:bg-sky-700 rounded-md">Close</button></div>
              </Modal>
            )}

            {modal && modal.type === 'clear' && (
              <Modal onClose={() => setModal(null)} title="Confirm Clear All Data">
                <p className="text-red-400 font-bold">This will permanently delete all files and your password from this browser.</p>
                <p className="mt-4">Are you sure you want to proceed?</p>
                <div className="flex justify-end gap-4 mt-6">
                  <button onClick={() => setModal(null)} className="px-4 py-2 bg-slate-600 hover:bg-slate-500 rounded-md">Cancel</button>
                  <button onClick={handleClearAllData} className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md">Yes, Delete Everything</button>
                </div>
              </Modal>
            )}
          </div>
        );
      };

      // --- START: App.tsx ---
      const App = () => {
        const { useState, useEffect, useCallback } = React;
        const [appState, setAppState] = useState(AppState.LOADING);
        const [encryptionKey, setEncryptionKey] = useState(null);
        const [toasts, setToasts] = useState([]);

        useEffect(() => {
          const checkSetup = async () => {
            try {
              await dbService.init();
              const config = await dbService.getConfig();
              setAppState(config ? AppState.LOCKED : AppState.SETUP);
            } catch (error) {
              console.error("Failed to initialize database:", error);
              addToast({ type: 'error', message: 'Error: Could not access browser storage.' });
              setAppState(AppState.ERROR);
            }
          };
          checkSetup();
        }, []);

        const addToast = (toast) => {
          const newToast = { ...toast, id: Date.now() + Math.random() };
          setToasts(prev => [...prev, newToast]);
        };
        
        const removeToast = (id) => {
          setToasts(prev => prev.filter(t => t.id !== id));
        };

        const handleLogin = useCallback((key) => {
          setEncryptionKey(key);
          setAppState(AppState.UNLOCKED);
          addToast({ type: 'success', message: 'Vault unlocked!' });
        }, []);

        const handleLogout = useCallback(() => {
          setEncryptionKey(null);
          setAppState(AppState.LOCKED);
          addToast({ type: 'info', message: 'Vault has been locked.' });
        }, []);
        
        const renderContent = () => {
          switch (appState) {
            case AppState.LOADING:
              return <div className="flex items-center justify-center h-screen"><div className="w-16 h-16 border-4 border-dashed rounded-full animate-spin border-sky-400"></div></div>;
            case AppState.SETUP:
            case AppState.LOCKED:
              return <AuthScreen appState={appState} onLogin={handleLogin} addToast={addToast} />;
            case AppState.UNLOCKED:
              if (!encryptionKey) { handleLogout(); return null; }
              return <Dashboard encryptionKey={encryptionKey} onLogout={handleLogout} addToast={addToast} />;
            case AppState.ERROR:
              return <div className="flex items-center justify-center h-screen text-center text-red-400"><p>A critical error occurred. Please check browser settings and refresh.</p></div>;
          }
        };

        return (
          <div className="min-h-screen bg-slate-900 font-sans">
            {renderContent()}
            <ToastContainer toasts={toasts} removeToast={removeToast} />
          </div>
        );
      };

      // --- START: index.tsx (Render call) ---
      const rootElement = document.getElementById('root');
      if (rootElement) {
        const root = ReactDOM.createRoot(rootElement);
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
      } else {
        console.error("Could not find root element to mount to");
      }

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
